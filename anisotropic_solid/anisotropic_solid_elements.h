// Implements anisotropic pvd equations
// Vectors which define the directions in which the material is anisotropic are passed to the constitutive
//  law as a vector of vectors.
// These vectors are computed as a function of local and global coordinates at the integral points.

#ifndef ANISOTROPIC_SOLID_ELEMENTS_HEADER
#define ANISOTROPIC_SOLID_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


#include "../solid/solid_elements.h"
#include "../anisotropic_constitutive/anisotropic_constitutive_laws.h"


namespace oomph
{

// The anisotropic PVD equations
template<unsigned DIM>
class AnisotropicPVDEquationsBase : public virtual PVDEquationsBase<DIM>
{
public:
 typedef void (*PrincipalVectorsOfAnisotropyFctPt)(const Vector<double>& s,
                                                   const Vector<double>& xi,
                                                   Vector<Vector<double>>& a);


 AnisotropicPVDEquationsBase() : Anisotropic_constitutive_law_pt(0)
 {
 }

 AnisotropicConstitutiveLaw*& anisotropic_constitutive_law_pt()
 {
  return Anisotropic_constitutive_law_pt;
 }

 PrincipalVectorsOfAnisotropyFctPt& principal_vectors_of_anisotropy_fct_pt()
 {
  return Principal_vectors_of_anisotropy_fct_pt;
 }

 PrincipalVectorsOfAnisotropyFctPt principal_vectors_of_anisotropy_fct_pt() const
 {
  return Principal_vectors_of_anisotropy_fct_pt;
 }

 void principal_vectors_of_anisotropy(const Vector<double>& s,
                                      const Vector<double>& xi,
                                      Vector<Vector<double>>& a)
 {
  // Number and size of the vectors is set by the assignment function
  if(Principal_vectors_of_anisotropy_fct_pt == 0) return;
  (*Principal_vectors_of_anisotropy_fct_pt)(s, xi, a);
 }

protected:
 PrincipalVectorsOfAnisotropyFctPt Principal_vectors_of_anisotropy_fct_pt;

 AnisotropicConstitutiveLaw* Anisotropic_constitutive_law_pt;
};


// Re-implements the PVDEquations class but introduces the principal vectors of anisotropy to the functions
// where needed.
template<unsigned DIM>
class AnisotropicPVDEquations : public virtual PVDEquations<DIM>,
                                               AnisotropicPVDEquationsBase<DIM>
{
public:
 // We override the get_stress function to get the principal vectors of anisotropy
 void get_stress(const Vector<double>& s, DenseMatrix<double>& sigma);

protected:
 // Override the fill in to contain the necessary steps of including the anisotropic components
 virtual void fill_in_generic_contribution_to_residuals_pvd(Vector<double>& residuals,
                                                            DenseMatrix<double>& jacobian,
                                                            const unsigned& flag) override;

 /// Provide an anisotropic version of get_stress from the metric tensors
 inline void anisotropic_get_stress(const DenseMatrix<double>& g,
                                    const DenseMatrix<double>& G,
                                    const Vector<Vector<double>>& a,
                                    DenseMatrix<double>& sigma)
 {
 #ifdef PARANOID
  // If the pointer to the constitutive law hasn't been set, issue an error
  if (this->Anisotropic_constitutive_law_pt == 0)
  {
   // Write an error message
   std::string error_message = "Elements derived from AnisotropicPVDEquations must have a constitutive law:\n";
   error_message += "set one using the anisotropic_constitutive_law_pt() member function";
   // Throw the error
   throw OomphLibError(error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  }
 #endif
  this->Anisotropic_constitutive_law_pt->calculate_second_piola_kirchhoff_stress(g, G, a, sigma);
 }

 /// Provide an anisotropic version of get_d_stress_dG_upper from the metric tensors
 inline void anisotropic_get_d_stress_dG_upper(const DenseMatrix<double>& g,
                                               const DenseMatrix<double>& G,
                                               const DenseMatrix<double>& sigma,
                                               const Vector<Vector<double>>& a,
                                               RankFourTensor<double>& d_sigma_dG)
 {
 #ifdef PARANOID
  // If the pointer to the constitutive law hasn't been set, issue an error
  if (this->Anisotropic_constitutive_law_pt == 0)
  {
   // Write an error message
   std::string error_message = "Elements derived from AnisotropicPVDEquations must have a constitutive law:\n";
   error_message += "set one using the anisotropic_constitutive_law_pt() member function";
   // Throw the error
   throw OomphLibError(error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  }
 #endif
  // Only bother with the symmetric part by passing false as last entry
  this->Anisotropic_constitutive_law_pt->calculate_d_second_piola_kirchhoff_stress_dG(g, G, sigma, a, d_sigma_dG, false);
 }
};


template<unsigned DIM, unsigned NNODE_1D>
class AnisotropicQPVDElement : public virtual QPVDElement<DIM, NNODE_1D>,
                               public virtual AnisotropicPVDEquations<DIM>
{
public:
 AnisotropicQPVDElement() : QPVDElement<DIM, NNODE_1D>(), AnisotropicPVDEquations<DIM>() {}

 void get_stress(const Vector<double>& s, DenseMatrix<double>& sigma)
 {
  AnisotropicPVDEquations<DIM>::get_stress(s, sigma);
 }

protected:
 void fill_in_generic_contribution_to_residuals_pvd(Vector<double>& residuals,
                                                    DenseMatrix<double>& jacobian,
                                                    const unsigned& flag)
 {
  AnisotropicPVDEquations<DIM>::fill_in_generic_contribution_to_residuals_pvd(residuals, jacobian, flag);
 }
};

template<unsigned NNODE_1D>
class FaceGeometry<AnisotropicQPVDElement<2, NNODE_1D>>
  : public virtual SolidQElement<1, NNODE_1D>
{
public:
  /// Constructor must call the constructor of the underlying solid element
  FaceGeometry() : SolidQElement<1, NNODE_1D>() {}
};

template<unsigned NNODE_1D>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElement<2, NNODE_1D>>>
  : public virtual PointElement
{
public:
  // Make sure that we call the constructor of the SolidQElement
  // Only the Intel compiler seems to need this!
  FaceGeometry() : PointElement() {}
};

template<unsigned NNODE_1D>
class FaceGeometry<AnisotropicQPVDElement<3, NNODE_1D>>
  : public virtual SolidQElement<2, NNODE_1D>
{
public:
  /// Constructor must call the constructor of the underlying solid element
  FaceGeometry() : SolidQElement<2, NNODE_1D>() {}
};

template<unsigned NNODE_1D>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElement<3, NNODE_1D>>>
  : public virtual SolidQElement<1, NNODE_1D>
{
public:
  /// Constructor must call the constructor of the underlying solid element
  FaceGeometry() : SolidQElement<1, NNODE_1D>() {}
};



template<unsigned DIM>
class AnisotropicHermitePVDElement : public virtual SolidQHermiteElement<DIM>,
                                     public virtual AnisotropicPVDEquations<DIM>
{
public:
 /// Constructor, there are no internal data points
 AnisotropicHermitePVDElement() : SolidQHermiteElement<DIM>(), AnisotropicPVDEquations<DIM>() {}
};


template<unsigned DIM>
class AnisotropicPVDEquationsWithPressure
  : public virtual PVDEquationsWithPressure<DIM>,
    public virtual AnisotropicPVDEquationsBase<DIM>
{
public:
 /// Constructor, by default the element is NOT incompressible.
 AnisotropicPVDEquationsWithPressure() : PVDEquationsWithPressure<DIM>(), AnisotropicPVDEquationsBase<DIM>()
 { }

 void get_stress(const Vector<double>& s, DenseMatrix<double>& sigma);

protected:
 inline void anisotropic_get_stress(const DenseMatrix<double>& g,
                                    const DenseMatrix<double>& G,
                                    const Vector<Vector<double>>& a,
                                    DenseMatrix<double>& sigma_dev,
                                    DenseMatrix<double>& Gcontra,
                                    double& gen_dil,
                                    double& inv_kappa)
 {
#ifdef PARANOID
  // If the pointer to the constitutive law hasn't been set, issue an error
  if (this->Anisotropic_constitutive_law_pt == 0)
  {
   // Write an error message
   std::string error_message =
    "Elements derived from AnisotropicPVDEquationsWithPressure \n";
   error_message += "must have a constitutive law:\n";
   error_message +=
    "set one using the anisotropic_constitutive_law_pt() member function";
   // Throw the error
   throw OomphLibError(
    error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  }
#endif
  this->Anisotropic_constitutive_law_pt->calculate_second_piola_kirchhoff_stress(
   g, G, a, sigma_dev, Gcontra, gen_dil, inv_kappa);
 }

 inline void anisotropic_get_d_stress_dG_upper(const DenseMatrix<double>& g,
                                      const DenseMatrix<double>& G,
                                      const DenseMatrix<double>& sigma,
                                      const double& gen_dil,
                                      const double& inv_kappa,
                                      const double& interpolated_solid_p,
                                      const Vector<Vector<double>>& a,
                                      RankFourTensor<double>& d_sigma_dG,
                                      DenseMatrix<double>& d_gen_dil_dG)
{
#ifdef PARANOID
 // If the pointer to the constitutive law hasn't been set, issue an error
 if (this->Anisotropic_constitutive_law_pt == 0)
 {
  // Write an error message
  std::string error_message =
   "Elements derived from AnisotropicPVDEquationsWithPressure \n";
  error_message += "must have a constitutive law:\n";
  error_message +=
   "set one using the anisotropic_constitutive_law_pt() member function";
  // Throw the error
  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
 }
#endif
  // Only bother with the symmetric part by passing false as last entry
  this->Anisotropic_constitutive_law_pt->calculate_d_second_piola_kirchhoff_stress_dG(
   g,
   G,
   sigma,
   gen_dil,
   inv_kappa,
   interpolated_solid_p,
   a,
   d_sigma_dG,
   d_gen_dil_dG,
   false);
 }

 inline void anisotropic_get_stress(const DenseMatrix<double>& g,
                                    const DenseMatrix<double>& G,
                                    const Vector<Vector<double>>& a,
                                    DenseMatrix<double>& sigma_dev,
                                    DenseMatrix<double>& Gcontra,
                                    double& detG)
 {
 #ifdef PARANOID
  // If the pointer to the constitutive law hasn't been set, issue an error
  if (this->Anisotropic_constitutive_law_pt == 0)
  {
   // Write an error message
   std::string error_message =
    "Elements derived from PVDEquationsWithPressure \n";
   error_message += "must have a constitutive law:\n";
   error_message +=
    "set one using the anisotropic_constitutive_law_pt() member function";
   // Throw the error
   throw OomphLibError(
    error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  }
 #endif
  this->Anisotropic_constitutive_law_pt->calculate_second_piola_kirchhoff_stress(
   g, G, a, sigma_dev, Gcontra, detG);
 }

 inline void anisotropic_get_d_stress_dG_upper(const DenseMatrix<double>& g,
                                   const DenseMatrix<double>& G,
                                   const DenseMatrix<double>& sigma,
                                   const double& detG,
                                   const double& interpolated_solid_p,
                                   const Vector<Vector<double>>& a,
                                   RankFourTensor<double>& d_sigma_dG,
                                   DenseMatrix<double>& d_detG_dG)
 {
 #ifdef PARANOID
  // If the pointer to the constitutive law hasn't been set, issue an error
  if (this->Anisotropic_constitutive_law_pt == 0)
  {
   // Write an error message
   std::string error_message =
    "Elements derived from PVDEquationsWithPressure \n";
   error_message += "must have a constitutive law:\n";
   error_message +=
    "set one using the anisotropic_constitutive_law_pt() member function";
   // Throw the error
   throw OomphLibError(
    error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  }
 #endif
  // Only bother with the symmetric part by passing false as last entry
  this->Anisotropic_constitutive_law_pt->calculate_d_second_piola_kirchhoff_stress_dG(
   g, G, sigma, detG, interpolated_solid_p, a, d_sigma_dG, d_detG_dG, false);
 }

 void fill_in_generic_residual_contribution_pvd_with_pressure(Vector<double>& residuals,
                                                              DenseMatrix<double>& jacobian,
                                                              DenseMatrix<double>& mass_matrix,
                                                              const unsigned& flag) override;
};

template<unsigned DIM>
class AnisotropicQPVDElementWithPressure : public virtual QPVDElementWithPressure<DIM>,
                                           public virtual AnisotropicPVDEquationsWithPressure<DIM>
{
public:
 AnisotropicQPVDElementWithPressure() : QPVDElementWithPressure<DIM>(),
                                        AnisotropicPVDEquationsWithPressure<DIM>()
 {}
};

template<>
class FaceGeometry<AnisotropicQPVDElementWithPressure<2>>
  : public virtual SolidQElement<1, 3>
{
public:
 /// Constructor must call constructor of underlying solid element
 FaceGeometry() : SolidQElement<1, 3>() {}
};

template<>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElementWithPressure<2>>>
  : public virtual PointElement
{
public:
 /// Constructor must call constructor of underlying solid element
 FaceGeometry() : PointElement() {}
};

template<>
class FaceGeometry<AnisotropicQPVDElementWithPressure<3>>
  : public virtual SolidQElement<2, 3>
{
public:
  /// Constructor must call constructor of underlying solid element
  FaceGeometry() : SolidQElement<2, 3>() {}
};

template<>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElementWithPressure<3>>>
  : public virtual SolidQElement<1, 3>
{
public:
  /// Constructor must call constructor of underlying solid element
  FaceGeometry() : SolidQElement<1, 3>() {}
};


template<unsigned DIM>
class AnisotropicQPVDElementWithContinuousPressure
  : public virtual QPVDElementWithContinuousPressure<DIM>,
    public virtual AnisotropicPVDEquationsWithPressure<DIM>
{
public:
 /// Constructor
 AnisotropicQPVDElementWithContinuousPressure() : QPVDElementWithContinuousPressure<DIM>(),
                                                  AnisotropicPVDEquationsWithPressure<DIM>()
 {}
};

template<>
class FaceGeometry<AnisotropicQPVDElementWithContinuousPressure<2>>
  : public virtual SolidQElement<1, 3>
{
public:
 /// Constructor must call constructor of the underlying Solid element
 FaceGeometry() : SolidQElement<1, 3>() {}
};

template<>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElementWithContinuousPressure<2>>>
  : public virtual PointElement
{
public:
 /// Constructor must call constructor of the underlying Point element
 FaceGeometry() : PointElement() {}
};

template<>
class FaceGeometry<AnisotropicQPVDElementWithContinuousPressure<3>>
  : public virtual SolidQElement<2, 3>
{
public:
 /// Constructor must call constructor of the underlying Solid element
 FaceGeometry() : SolidQElement<2, 3>() {}
};

template<>
class FaceGeometry<FaceGeometry<AnisotropicQPVDElementWithContinuousPressure<3>>>
  : public virtual SolidQElement<1, 3>
{
public:
 /// Constructor must call constructor of the underlying element
 FaceGeometry() : SolidQElement<1, 3>() {}
};



} // End namespace

#endif