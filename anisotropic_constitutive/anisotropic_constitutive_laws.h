// Implements anisotropic constitutive equations and strain energy functions.
// Vectors which define the directions in which the material is anisotropic are passed to the constitutive
//  law as a vector of vectors.

// Essentially a copy and paste of the constitutive/strain energy classes from the base oomph-lib but with additional
//  arguments to acommodate the vectors which define the anisotropic properties of the material.

// Add a paranoid check function to ensure that the number of vectors passed to the functions are consistent
//  with the number required by the anisotropic constitutive model.

// Principal vectors of anisotropy - PVA

// Strain invariants can be computed differently depending on the anisotropic constitutive law being considered.
// I think this means that calculation of the strain invariants has to be passed to the strain energy function
// rather than being calculated by a boiler plate class (IsotropicStrainEnergyFunctionConstitutiveLaw).
// This means that all anisotropic strain energy functions will be greatly more complicated than their isotropic
// counterparts.

// Consider: maybe the first 3 (isotropic) invariants are always the same
//  then we just need to provide how to calculate any additional strain invariants and their derivatives with respect to the strain
// How are incompressible problems affected by this???
// Are quantities for incompressible problems always calculated the same way from compressible ones?

// I[0] I[1] I[2] are standard isotropic strain invariants. I[2] looks to be important for incompressible problems
// \sigma_{ij} = \frac{\partial W}{\partial I_k}\frac{\partial I_k}{\partial \gamma_{ij}}
// Isotropic strain energy functions already calculate dId\gamma_{ij} so adding derivatives for the additional strain invariants
//  is reasonable.
// Need the strain energy function class to calculate:
//     \frac{\partial W}{\partial I_k}
// and \frac{\partial I_k}{\partial \gamma_{ij}}
// for the additional strain invariants or for all strain invariants?
//  I think \frac{\partial I_k}{\partial \gamma_{ij}} just for the new strain invariants, and \frac{\partial W}{\partial I_k}
//  for all strain invariants including the isotropic ones
// Then the calculation of the stress tensor and related quantities needed for incompressibility can be handled in the standard way



#ifndef OOMPH_ANISOTROPIC_CONSTITUTIVE_LAWS_HEADER
#define OOMPH_ANISOTROPIC_CONSTITUTIVE_LAWS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "generic/oomph_utilities.h"
#include "generic/matrices.h"
#include "constitutive/constitutive_laws.h"

namespace oomph
{
namespace Verify_PVA
{
 // Inline check that the number of principal vectors of anisotropy is correct
 inline static bool verify_number_of_pva(const Vector<Vector<double>>& a,
                                         const unsigned& N_Principal_Vectors_Of_Anisotropy)
 {
 #ifdef PARANOID
  if(N_Principal_Vectors_Of_Anisotropy != a.size())
  {
   return false;
  }
  return true;
 #endif
 }
}; // End namespace
//=====================================================================
/// Base class for anisotropic strain energy functions to be used in solid
/// mechanics computations.
//====================================================================
class AnisotropicStrainEnergyFunction
{
public:
 AnisotropicStrainEnergyFunction() : N_Principal_Vectors_Of_Anisotropy(0),
                                     N_Additional_Strain_Invariants(0)
 {}

 virtual ~AnisotropicStrainEnergyFunction() {}

 virtual double W(const DenseMatrix<double>& gamma, const Vector<Vector<double>> a)
 {
  std::string error_message =
   "The anisotropic strain-energy function as a function of the strain-tensor,\n";
  error_message +=
   "gamma and principal vectors of anisotropy a, is not implemented for this strain energy function.\n";

  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  return 0.0;
 }

 /// Return the strain energy in terms of the strain invariants
 /// the invariants includes the strain invariants due to the PVA
 virtual double W(const Vector<double>& I)
 {
  std::string error_message =
   "The strain-energy function as a function of the strain\n ";
  error_message +=
   "invariants, is not implemented for this strain\n ";
  error_message += "energy function\n";

  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  return 0.0;
 }

 /// Return the derivatives of the strain energy function with
 /// respect to the components of the strain tensor (default is to use
 /// finite differences).
 virtual void derivative(const DenseMatrix<double>& gamma,
                         const Vector<Vector<double>> a,
                         DenseMatrix<double>& dWdgamma)
 {
  //TODO implement FD method
  throw OomphLibError(
   "Sorry, the FD setup of dW/dgamma hasn't been implemented yet",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 /// Return the derivatives of the strain energy function with
 /// respect to the strain invariants. Default version is to use finite
 /// differences
 virtual void derivatives(Vector<double>& I, Vector<double>& dWdI)
 {
   // Calculate the derivatives of the strain-energy-function wrt the strain
   // invariants
   double FD_Jstep = 1.0e-8; // Usual comments about global stuff
   double energy = W(I);

   // Loop over the strain invariants
   for (unsigned i = 0; i < 3 + N_Additional_Strain_Invariants; i++)
   {
     // Store old value
     double I_prev = I[i];
     // Increase ith strain invariant
     I[i] += FD_Jstep;
     // Get the new value of the strain energy
     double energy_new = W(I);
     // Calculate the value of the derivative
     dWdI[i] = (energy_new - energy) / FD_Jstep;
     // Reset value of ith strain invariant
     I[i] = I_prev;
   }
 }

 /// Pure virtual function in which the user must declare if the
 /// constitutive equation requires an incompressible formulation
 /// in which the volume constraint is enforced explicitly.
 /// Used as a sanity check in PARANOID mode.
 virtual bool requires_incompressibility_constraint() = 0;

protected:
 // How many PVA are required by the model
 unsigned N_Principal_Vectors_Of_Anisotropy;
 // How many additional strain invariants are introduced by the PVA
 unsigned N_Additional_Strain_Invariants; 
};



// Essentially a direct copy from ConstitutiveLaw with a few new Calculate second Piola Kitchhoff stress functions
//  with an additional argument to account for the vectors of anisotropy
class AnisotropicConstitutiveLaw : ConstitutiveLaw
{
public:
 AnisotropicConstitutiveLaw() : ConstitutiveLaw() {}

 virtual ~AnisotropicConstitutiveLaw() {}

 // The below functions are overloading functions from ConstitutiveLaw but with an additional
 // argument to pass in the PVA

 /// Calculate the contravariant 2nd Piola Kirchhoff
 /// stress tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor and the
 /// matrix in which to return the stress tensor
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma) = 0;

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchhoff stress tensor with respect to the deformed metric
 /// tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor, the current value of
 /// the stress tensor and the
 /// rank four tensor in which to return the derivatives of the stress tensor
 /// The default implementation uses finite differences, but can be
 /// overloaded for constitutive laws in which an analytic formulation
 /// is possible.
 /// If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  const bool& symmetrize_tensor = true);


 /// Calculate the deviatoric part
 /// \f$ \overline{ \sigma^{ij}}\f$  of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// Also return the contravariant deformed metric
 /// tensor and the determinant of the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials for which
 /// \f$ \sigma^{ij} = - p G^{ij} +\overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined by
 /// \f$ \det G_{ij} - \det g_{ij} = 0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& G_contra,
  double& Gdet)
  {
   throw OomphLibError(
    "Incompressible formulation not implemented for this constitutive law",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// with respect to the deformed metric tensor.
 /// Also return the derivatives of the determinant of the
 /// deformed metric tensor with respect to the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials.
 /// The default implementation uses finite differences for the
 /// derivatives that depend on the constitutive law, but not
 /// for the derivatives of the determinant, which are generic.
 /// / If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& detG,
  const double& interpolated_solid_p,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_detG_dG,
  const bool& symmetrize_tensor = true);

 /// Calculate the deviatoric part of the contravariant
 /// 2nd Piola Kirchoff stress tensor. Also return the contravariant
 /// deformed metric tensor, the generalised dilatation, \f$ d, \f$ and
 /// the inverse of the bulk modulus \f$ \kappa\f$. This form is appropriate
 /// for near-incompressible materials for which
 /// \f$ \sigma^{ij} = -p G^{ij} + \overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined from
 /// \f$ p / \kappa - d =0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& Gcontra,
  double& gen_dil,
  double& inv_kappa)
 {
  throw OomphLibError(
   "Near-incompressible formulation not implemented for constitutive law",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchoff stress tensor with respect to the deformed metric
 /// tensor. Also return the derivatives of the generalised dilatation,
 /// \f$ d, \f$ with respect to the deformed metric tensor.
 /// This form is appropriate
 /// for near-incompressible materials.
 /// The default implementation uses finite differences.
 /// If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& gen_dil,
  const double& inv_kappa,
  const double& interpolated_solid_p,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_gen_dil_dG,
  const bool& symmetrize_tensor = true);

 /// Pure virtual function in which the user must declare if the
 /// constitutive equation requires an incompressible formulation
 /// in which the volume constraint is enforced explicitly.
 /// Used as a sanity check in PARANOID mode.
 virtual bool requires_incompressibility_constraint() = 0;

protected:
 // How many PVA are required by the model
 unsigned N_Principal_Vectors_Of_Anisotropy;
 // How many additional strain invariants are introduced by the PVA
 unsigned N_Additional_Strain_Invariants; 
};


// Anisotropic constitutive law where the second Piola-Kirchhoff stress tensor and its derivatives are calculated from
// an anisotropic strain energy function.
class AnisotropicStrainEnergyFunctionConstitutiveLaw : public AnisotropicConstitutiveLaw
{
private:
 AnisotropicStrainEnergyFunction* Strain_Energy_Function_pt;

public:
 AnisotropicStrainEnergyFunctionConstitutiveLaw(AnisotropicStrainEnergyFunction* const& strain_energy_function_pt)
  : AnisotropicConstitutiveLaw(), Strain_Energy_Function_pt(strain_energy_function_pt)
 {}

 /// Calculate the contravariant 2nd Piola Kirchhoff
 /// stress tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor and the
 /// matrix in which to return the stress tensor.
 /// Uses correct 3D invariants for 2D (plane strain) problems.
 void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                              const DenseMatrix<double>& G,
                                              const Vector<Vector<double>>& a,
                                              DenseMatrix<double>& sigma) override;

 /// Calculate the deviatoric part
 /// \f$ \overline{ \sigma^{ij}}\f$  of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// Also return the contravariant deformed metric
 /// tensor and the determinant of the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials for which
 /// \f$ \sigma^{ij} = - p G^{ij} +\overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined by
 /// \f$ \det G_{ij} - \det g_{ij} = 0 \f$.
 void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                              const DenseMatrix<double>& G,
                                              const Vector<Vector<double>>& a,
                                              DenseMatrix<double>& sigma_dev,
                                              DenseMatrix<double>& G_contra,
                                              double& Gdet) override;

 /// Calculate the deviatoric part of the contravariant
 /// 2nd Piola Kirchoff stress tensor. Also return the contravariant
 /// deformed metric tensor, the generalised dilatation, \f$ d, \f$ and
 /// the inverse of the bulk modulus \f$ \kappa\f$. This form is appropriate
 /// for near-incompressible materials for which
 /// \f$ \sigma^{ij} = -p G^{ij} + \overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined from
 /// \f$ p / \kappa - d =0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                                      const DenseMatrix<double>& G,
                                                      const Vector<Vector<double>>& a,
                                                      DenseMatrix<double>& sigma_dev,
                                                      DenseMatrix<double>& Gcontra,
                                                      double& gen_dil,
                                                      double& inv_kappa) override;
};



} // End namespace

#endif