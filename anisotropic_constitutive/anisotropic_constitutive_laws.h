// Implements anisotropic constitutive equations and strain energy functions.
// Vectors which define the directions in which the material is anisotropic are passed to the constitutive
//  law as a vector of vectors.

// Essentially a copy and paste of the constitutive/strain energy classes from the base oomph-lib but with additional
//  arguments to acommodate the vectors which define the anisotropic properties of the material.

// Add a paranoid check function to ensure that the number of vectors passed to the functions are consistent
//  with the number required by the anisotropic constitutive model.

// Principal vectors of anisotropy - PVA

// Strain invariants can be computed differently depending on the anisotropic constitutive law being considered.
// I think this means that calculation of the strain invariants has to be passed to the strain energy function
// rather than being calculated by a boiler plate class (IsotropicStrainEnergyFunctionConstitutiveLaw).
// This means that all anisotropic strain energy functions will be greatly more complicated than their isotropic
// counterparts.

// Consider: maybe the first 3 (isotropic) invariants are always the same
//  then we just need to provide how to calculate any additional strain invariants and their derivatives with respect to the strain
// How are incompressible problems affected by this???
// Are quantities for incompressible problems always calculated the same way from compressible ones?

// I[0] I[1] I[2] are standard isotropic strain invariants. I[2] looks to be important for incompressible problems
// \sigma_{ij} = \frac{\partial W}{\partial I_k}\frac{\partial I_k}{\partial \gamma_{ij}}
// Isotropic strain energy functions already calculate dId\gamma_{ij} so adding derivatives for the additional strain invariants
//  is reasonable.
// Need the strain energy function class to calculate:
//     \frac{\partial W}{\partial I_k}
// and \frac{\partial I_k}{\partial \gamma_{ij}}
// for the additional strain invariants or for all strain invariants?
//  I think \frac{\partial I_k}{\partial \gamma_{ij}} just for the new strain invariants, and \frac{\partial W}{\partial I_k}
//  for all strain invariants including the isotropic ones
// Then the calculation of the stress tensor and related quantities needed for incompressibility can be handled in the standard way


// Need a way in future of being able to pass additional information e.g. active strain/stress
//  to the anisotropic constitutive equations. Active strain/stress is distinct from body forces
//  in the formulation. This could be handled by repurposing the a entry. Additional data could be
//  added to this vector without altering underlying functionality and without requiring new arguments.
// In active stress method of adding cell generated stress to a tissue model, the stress is often added
//  by a term which looks like F(\lamdba)f_if_j =  F(\lambda)\frac{\partial I_3}{\partial G_{ij}}
//  so adding active stress to this model corresponds to setting dW/dI_3 = F(\lambda)

// Decided to include it in this way. Principal vectors of anisotropy can also contain any additional information.
// Strain invariants can then be added to represent any quantities needed in the formulation and these can be
//  removed from any subsequent calculation of the piola kirchhoff stress tensor.


#ifndef OOMPH_ANISOTROPIC_CONSTITUTIVE_LAWS_HEADER
#define OOMPH_ANISOTROPIC_CONSTITUTIVE_LAWS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../constitutive/constitutive_laws.h"

namespace oomph
{
namespace Verify_PVA
{
 // Inline check that the number of principal vectors of anisotropy is correct
 inline static bool verify_number_of_pva(const Vector<Vector<double>>& a,
                                         const unsigned& N_Principal_Vectors_Of_Anisotropy)
 {
  if(N_Principal_Vectors_Of_Anisotropy != a.size())
  {
   return false;
  }
  return true;
 }
} // End namespace
//=====================================================================
/// Base class for anisotropic strain energy functions to be used in solid
/// mechanics computations.
//====================================================================
class AnisotropicStrainEnergyFunction
{
public:
 AnisotropicStrainEnergyFunction() : N_Principal_Vectors_Of_Anisotropy(0),
                                     N_Additional_Strain_Invariants(0)
 {}

 virtual ~AnisotropicStrainEnergyFunction() {}

 // Calculate the additional strain invariants due to the PVA and their derivatives
 // with respect to the deformed metric tensor.
 virtual void I(const DenseMatrix<double>& g,
                const DenseMatrix<double>& g_up,
                const DenseMatrix<double>& G,
                const DenseMatrix<double>& G_up,
                const double& detg,
                const double& getG,
                const Vector<Vector<double>>& a,
                Vector<double>& I,
                Vector<DenseMatrix<double>>& dIdG)
 {
  std::string error_message =
   "The additional strain invariants as a function of the undeformed and deformed metric tensors,\n";
  error_message +=
   "and principal vectors of anisotropy a, is not implemented for this strain energy function.\n";

  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
 }

 // Calculate the strain energy function as a function of the strain and PVA
 virtual double W(const DenseMatrix<double>& gamma, const Vector<Vector<double>> a)
 {
  std::string error_message =
   "The anisotropic strain-energy function as a function of the strain-tensor,\n";
  error_message +=
   "gamma and principal vectors of anisotropy a, is not implemented for this strain energy function.\n";

  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  return 0.0;
 }

 /// Return the strain energy in terms of the strain invariants
 /// the invariants includes the strain invariants due to the PVA.
 /// The first 3 invariants are alaways the isotropic invariants
 virtual double W(const Vector<double>& I)
 {
  std::string error_message =
   "The strain-energy function as a function of the strain\n ";
  error_message +=
   "invariants, is not implemented for this strain\n ";
  error_message += "energy function\n";

  throw OomphLibError(
   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
  return 0.0;
 }

 /// Return the derivatives of the strain energy function with
 /// respect to the components of the strain tensor (default is to use
 /// finite differences).
 virtual void derivative(const DenseMatrix<double>& gamma,
                         const Vector<Vector<double>> a,
                         DenseMatrix<double>& dWdgamma)
 {
  const unsigned dim = gamma.ncol();

  DenseMatrix<double> gamma_temp(gamma);

  // Calculate the derivatives of the strain-energy-function wrt the strain
  double FD_Jstep = 1.0e-8; // Usual comments about global stuff
  double energy = W(gamma_temp, a);

  // Loop over the strain invariants
  for (unsigned i = 0; i < dim; i++)
  {
   for (unsigned j = 0; j < dim; j++)
   {
    // Store old value
    double gamma_ij_prev = gamma_temp(i,j);
    // Increase i,j-th strain entry
    gamma_temp(i,j) += FD_Jstep;
    // Get the new value of the strain energy
    double energy_new = W(gamma_temp, a);
    // Calculate the value of the derivative
    dWdgamma(i,j) = (energy_new - energy) / FD_Jstep;
    // Reset value of i,j-th strain entry
    gamma_temp(i,j) = gamma_ij_prev;
   }
  }
 }

 /// Return the derivatives of the strain energy function with
 /// respect to the strain invariants. Default version is to use finite
 /// differences
 virtual void derivatives(Vector<double>& I, Vector<double>& dWdI)
 {
  // Calculate the derivatives of the strain-energy-function wrt the strain
  // invariants
  double FD_Jstep = 1.0e-8; // Usual comments about global stuff
  double energy = W(I);

  // Loop over the strain invariants
  for (unsigned i = 0; i < 3 + get_n_additional_strain_invariants(); i++)
  {
   // Store old value
   double I_prev = I[i];
   // Increase ith strain invariant
   I[i] += FD_Jstep;
   // Get the new value of the strain energy
   double energy_new = W(I);
   // Calculate the value of the derivative
   dWdI[i] = (energy_new - energy) / FD_Jstep;
   // Reset value of ith strain invariant
   I[i] = I_prev;
  }
 }

 /// Pure virtual function in which the user must declare if the
 /// constitutive equation requires an incompressible formulation
 /// in which the volume constraint is enforced explicitly.
 /// Used as a sanity check in PARANOID mode.
 virtual bool requires_incompressibility_constraint() = 0;

 inline const unsigned get_n_principal_vectors_of_anisotropy() const
 {
  return N_Principal_Vectors_Of_Anisotropy;
 }

 inline const unsigned get_n_additional_strain_invariants() const
 {
  return N_Additional_Strain_Invariants;
 }

protected:
 // How many PVA are required by the model
 unsigned N_Principal_Vectors_Of_Anisotropy;
 // How many additional strain invariants are introduced by the PVA
 unsigned N_Additional_Strain_Invariants; 
};



// Essentially a direct copy from ConstitutiveLaw with a few new Calculate second Piola Kitchhoff stress functions
//  with an additional argument to account for the principal vectors of anisotropy
class AnisotropicConstitutiveLaw : public ConstitutiveLaw
{
public:
 AnisotropicConstitutiveLaw() : ConstitutiveLaw() {}

 virtual ~AnisotropicConstitutiveLaw() {}

 // The below functions are overloading functions from ConstitutiveLaw but with an additional
 // argument to pass in the PVA

 /// Calculate the contravariant 2nd Piola Kirchhoff
 /// stress tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor and the
 /// matrix in which to return the stress tensor
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma) = 0;

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchhoff stress tensor with respect to the deformed metric
 /// tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor, the current value of
 /// the stress tensor and the
 /// rank four tensor in which to return the derivatives of the stress tensor
 /// The default implementation uses finite differences, but can be
 /// overloaded for constitutive laws in which an analytic formulation
 /// is possible.
 /// If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  const bool& symmetrize_tensor = true);

 /// Calculate the deviatoric part
 /// \f$ \overline{ \sigma^{ij}}\f$  of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// Also return the contravariant deformed metric
 /// tensor and the determinant of the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials for which
 /// \f$ \sigma^{ij} = - p G^{ij} +\overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined by
 /// \f$ \det G_{ij} - \det g_{ij} = 0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& G_contra,
  double& Gdet)
  {
   throw OomphLibError(
    "Incompressible formulation not implemented for this constitutive law",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// with respect to the deformed metric tensor.
 /// Also return the derivatives of the determinant of the
 /// deformed metric tensor with respect to the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials.
 /// The default implementation uses finite differences for the
 /// derivatives that depend on the constitutive law, but not
 /// for the derivatives of the determinant, which are generic.
 /// / If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& detG,
  const double& interpolated_solid_p,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_detG_dG,
  const bool& symmetrize_tensor = true);

 /// Calculate the deviatoric part of the contravariant
 /// 2nd Piola Kirchoff stress tensor. Also return the contravariant
 /// deformed metric tensor, the generalised dilatation, \f$ d, \f$ and
 /// the inverse of the bulk modulus \f$ \kappa\f$. This form is appropriate
 /// for near-incompressible materials for which
 /// \f$ \sigma^{ij} = -p G^{ij} + \overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined from
 /// \f$ p / \kappa - d =0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const Vector<Vector<double>>& a,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& Gcontra,
  double& gen_dil,
  double& inv_kappa)
 {
  throw OomphLibError(
   "Near-incompressible formulation not implemented for constitutive law",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 /// Calculate the derivatives of the contravariant
 /// 2nd Piola Kirchoff stress tensor with respect to the deformed metric
 /// tensor. Also return the derivatives of the generalised dilatation,
 /// \f$ d, \f$ with respect to the deformed metric tensor.
 /// This form is appropriate
 /// for near-incompressible materials.
 /// The default implementation uses finite differences.
 /// If the boolean flag symmetrize_tensor is false, only the
 /// "upper  triangular" entries of the tensor will be filled in. This is
 /// a useful efficiency when using the derivatives in Jacobian calculations.
 virtual void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& gen_dil,
  const double& inv_kappa,
  const double& interpolated_solid_p,
  const Vector<Vector<double>>& a,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_gen_dil_dG,
  const bool& symmetrize_tensor = true);

 /// Pure virtual function in which the user must declare if the
 /// constitutive equation requires an incompressible formulation
 /// in which the volume constraint is enforced explicitly.
 /// Used as a sanity check in PARANOID mode.
 virtual bool requires_incompressibility_constraint() = 0;

 // Virtual so that AnisotropicStrainEnergyFunctionConstitutiveLaw can get these values from the strain energy function
 virtual inline const unsigned get_n_principal_vectors_of_anisotropy()
 {
  return N_Principal_Vectors_Of_Anisotropy;
 }

 virtual inline const unsigned get_n_additional_strain_invariants()
 {
  return N_Additional_Strain_Invariants;
 }


 // BEGIN Intentionally break the isotropic strain energy functions
 void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  DenseMatrix<double>& sigma)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  RankFourTensor<double>& d_sigma_dG,
  const bool& symmetrize_tensor = true)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

  void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& G_contra,
  double& Gdet)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& detG,
  const double& interpolated_solid_p,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_detG_dG,
  const bool& symmetrize_tensor = true)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 void calculate_second_piola_kirchhoff_stress(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  DenseMatrix<double>& sigma_dev,
  DenseMatrix<double>& Gcontra,
  double& gen_dil,
  double& inv_kappa)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }

 void calculate_d_second_piola_kirchhoff_stress_dG(
  const DenseMatrix<double>& g,
  const DenseMatrix<double>& G,
  const DenseMatrix<double>& sigma,
  const double& gen_dil,
  const double& inv_kappa,
  const double& interpolated_solid_p,
  RankFourTensor<double>& d_sigma_dG,
  DenseMatrix<double>& d_gen_dil_dG,
  const bool& symmetrize_tensor = true)
 {
  throw OomphLibError(
   "Isotropic stress functions are intentionally broken in AnisotropicConstitutiveLaw",
   OOMPH_CURRENT_FUNCTION,
   OOMPH_EXCEPTION_LOCATION);
 }
 //END intentionally break all isotropic stress functions


protected:
 // How many PVA are required by the model
 unsigned N_Principal_Vectors_Of_Anisotropy;
 // How many additional strain invariants are introduced by the PVA
 unsigned N_Additional_Strain_Invariants; 
};


// Anisotropic constitutive law where the second Piola-Kirchhoff stress tensor and its derivatives are calculated from
// an anisotropic strain energy function.
class AnisotropicStrainEnergyFunctionConstitutiveLaw : public AnisotropicConstitutiveLaw
{
private:
 AnisotropicStrainEnergyFunction* Strain_Energy_Function_pt;

public:
 AnisotropicStrainEnergyFunctionConstitutiveLaw(AnisotropicStrainEnergyFunction* const& strain_energy_function_pt)
  : AnisotropicConstitutiveLaw(), Strain_Energy_Function_pt(strain_energy_function_pt)
 {}

 /// Calculate the contravariant 2nd Piola Kirchhoff
 /// stress tensor. Arguments are the
 /// covariant undeformed and deformed metric tensor and the
 /// matrix in which to return the stress tensor.
 /// Uses correct 3D invariants for 2D (plane strain) problems.
 void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                              const DenseMatrix<double>& G,
                                              const Vector<Vector<double>>& a,
                                              DenseMatrix<double>& sigma) override;

 /// Calculate the deviatoric part
 /// \f$ \overline{ \sigma^{ij}}\f$  of the contravariant
 /// 2nd Piola Kirchhoff stress tensor \f$ \sigma^{ij}\f$.
 /// Also return the contravariant deformed metric
 /// tensor and the determinant of the deformed metric tensor.
 /// This form is appropriate
 /// for truly-incompressible materials for which
 /// \f$ \sigma^{ij} = - p G^{ij} +\overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined by
 /// \f$ \det G_{ij} - \det g_{ij} = 0 \f$.
 void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                              const DenseMatrix<double>& G,
                                              const Vector<Vector<double>>& a,
                                              DenseMatrix<double>& sigma_dev,
                                              DenseMatrix<double>& G_contra,
                                              double& Gdet) override;

 /// Calculate the deviatoric part of the contravariant
 /// 2nd Piola Kirchoff stress tensor. Also return the contravariant
 /// deformed metric tensor, the generalised dilatation, \f$ d, \f$ and
 /// the inverse of the bulk modulus \f$ \kappa\f$. This form is appropriate
 /// for near-incompressible materials for which
 /// \f$ \sigma^{ij} = -p G^{ij} + \overline{ \sigma^{ij}}  \f$
 /// where the "pressure" \f$ p \f$ is determined from
 /// \f$ p / \kappa - d =0 \f$.
 virtual void calculate_second_piola_kirchhoff_stress(const DenseMatrix<double>& g,
                                                      const DenseMatrix<double>& G,
                                                      const Vector<Vector<double>>& a,
                                                      DenseMatrix<double>& sigma_dev,
                                                      DenseMatrix<double>& Gcontra,
                                                      double& gen_dil,
                                                      double& inv_kappa) override;

 /// State if the constitutive equation requires an incompressible
 /// formulation in which the volume constraint is enforced explicitly.
 /// Used as a sanity check in PARANOID mode. This is determined
 /// by interrogating the associated strain energy function.
 bool requires_incompressibility_constraint()
 {
   return Strain_Energy_Function_pt->requires_incompressibility_constraint();
 }

 inline const unsigned get_n_principal_vectors_of_anisotropy() override
 {
  return Strain_Energy_Function_pt->get_n_principal_vectors_of_anisotropy();
 }

 inline const unsigned get_n_additional_strain_invariants() override
 {
  return Strain_Energy_Function_pt->get_n_additional_strain_invariants();
 }
};



} // End namespace

#endif